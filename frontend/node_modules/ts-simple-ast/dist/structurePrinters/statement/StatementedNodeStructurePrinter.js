"use strict";
var __extends = (this && this.__extends)/* istanbul ignore next */ || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("../../utils");
var StructurePrinter_1 = require("../StructurePrinter");
var class_1 = require("../class");
var interface_1 = require("../interface");
var enum_1 = require("../enum");
var function_1 = require("../function");
var namespace_1 = require("../namespace");
var types_1 = require("../types");
var StatementedNodeStructurePrinter = /** @class */ (function (_super) {
    __extends(StatementedNodeStructurePrinter, _super);
    function StatementedNodeStructurePrinter(writer, options) {
        var _this = _super.call(this, writer) || this;
        _this.options = options;
        _this.classWriter = new class_1.ClassDeclarationStructurePrinter(_this.writer, _this.options);
        _this.interfaceWriter = new interface_1.InterfaceDeclarationStructurePrinter(_this.writer);
        _this.enumWriter = new enum_1.EnumDeclarationStructurePrinter(_this.writer);
        _this.functionWriter = new function_1.FunctionDeclarationStructurePrinter(_this.writer);
        _this.namespaceWriter = new namespace_1.NamespaceDeclarationStructurePrinter(_this.writer, _this.options);
        _this.typeAliasWriter = new types_1.TypeAliasDeclarationStructurePrinter(_this.writer);
        return _this;
    }
    StatementedNodeStructurePrinter.prototype.printText = function (structure) {
        conditionalBlankLine(this.writer, structure.typeAliases);
        this.typeAliasWriter.printTexts(structure.typeAliases);
        conditionalBlankLine(this.writer, structure.interfaces);
        this.interfaceWriter.printTexts(structure.interfaces);
        conditionalBlankLine(this.writer, structure.enums);
        this.enumWriter.printTexts(structure.enums);
        conditionalBlankLine(this.writer, structure.functions);
        this.functionWriter.printTexts(structure.functions);
        conditionalBlankLine(this.writer, structure.classes);
        this.classWriter.printTexts(structure.classes);
        conditionalBlankLine(this.writer, structure.namespaces);
        this.namespaceWriter.printTexts(structure.namespaces);
        function conditionalBlankLine(writer, structures) {
            if (!writer.isAtStartOfFirstLineOfBlock() && !utils_1.ArrayUtils.isNullOrEmpty(structures))
                writer.blankLine();
        }
    };
    return StatementedNodeStructurePrinter;
}(StructurePrinter_1.StructurePrinter));
exports.StatementedNodeStructurePrinter = StatementedNodeStructurePrinter;
